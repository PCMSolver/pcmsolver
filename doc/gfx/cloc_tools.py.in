#
#  PCMSolver, an API for the Polarizable Continuum Model
#  Copyright (C) 2018 Roberto Di Remigio, Luca Frediani and contributors.
#
#  This file is part of PCMSolver.
#
#  PCMSolver is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  PCMSolver is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with PCMSolver.  If not, see <http://www.gnu.org/licenses/>.
#
#  For information on the complete list of contributors to the
#  PCMSolver API, see: <http://pcmsolver.readthedocs.io/>
#

# Execute cloc.pl Perl script and wrap results in a nicer format.
# cloc script by Al Danial, available at http://cloc.sourceforge.net/
# licensed under the GNU General Public License v2
# (c) Roberto Di Remigio  <roberto.d.remigio@uit.no>
# licensed under the GNU Lesser General Public License

from __future__ import print_function
import subprocess
import glob
import os
import tempfile
from yaml import load
try:
    from yaml import CLoader as Loader
except ImportError:
    from yaml import Loader
import time


def cloc_command(perl, cloc_script, files, *args):
    """Wrapper to the cloc.pl Perl script.

    Keyword arguments:
    perl -- perl executable
    cloc_script -- the cloc.pl script
    files -- list of files to parse
    args -- additional command line arguments to cloc.pl
    """
    command = [perl, cloc_script] + [str(f).strip() for f in files] + list(args)
    return subprocess.check_output(command, shell=False)


def bar_chart(dirname, language, savedir):
    """Generates matplotlib script for lines of code bar chart.

    Keyword arguments:
    dirname -- directory where the lines of code counting has to take place
    language -- the programming language of the source files: C++, C or Fortran
    savedir -- where YAML files are to be saved
    """
    tag = os.path.basename(dirname)
    root_dir = '@PROJECT_BINARY_DIR@/doc/gfx/matplotlib'
    if not os.path.exists(root_dir):
        os.makedirs(root_dir)
    plot_script = os.path.join(root_dir, tag + '.py')
    # Read from template from file
    script = '\n'
    with open('@PROJECT_SOURCE_DIR@/doc/gfx/bar_chart.txt', 'r') as myfile:
        script += myfile.read()
    with open(plot_script, 'w+') as bar_plot:
        bar_plot.write(header())
        # Language specific part: counting and printing data to the script
        if (language == 'C++'):
            data = count_CXX(sorted(glob.glob(dirname + '/*.hpp')), sorted(glob.glob(dirname + '/*.cpp')), savedir)
            bar_plot.write(data_CXX(data, tag))
        elif (language == 'C'):
            data = count_C(sorted(glob.glob(dirname + '/*.h')), sorted(glob.glob(dirname + '/*.c')), savedir)
            bar_plot.write(data_C(data, tag))
        else:
            data = count_Fortran(
                sorted(glob.glob(dirname + '/*.F90')) + sorted(glob.glob(dirname + '/*.f90')) +
                sorted(glob.glob(dirname + '/*.F77')) + sorted(glob.glob(dirname + '/*.f77')), savedir)
            bar_plot.write(data_Fortran(data, tag))
        # Print body of the script
        bar_plot.write(script)
    return plot_script


def count_CXX(headers, sources, savedir):
    """Counts lines of C++ source code.

    Keyword arguments:
    headers -- list of header files
    sources -- list of source files
    savedir -- where to save the YAML output
    """
    hpp_yml = os.path.join(savedir, 'scratch_hpp.yml')
    cpp_yml = os.path.join(savedir, 'scratch_cpp.yml')
    if headers:
        cloc_wrapper(headers, hpp_yml)
    if sources:
        cloc_wrapper(sources, cpp_yml)
    return process_YAML_CXX(hpp_yml, cpp_yml)


def count_C(headers, sources, savedir):
    """Counts lines of C source code.

    Keyword arguments:
    headers -- list of header files
    sources -- list of source files
    savedir -- where to save the YAML output
    """
    h_yml = os.path.join(savedir, 'scratch_h.yml')
    c_yml = os.path.join(savedir, 'scratch_c.yml')
    if headers:
        cloc_wrapper(headers, h_yml)
    if sources:
        cloc_wrapper(sources, c_yml)
    return process_YAML_C(h_yml, c_yml)


def count_Fortran(sources, savedir):
    """Counts lines of Fortran source code.

    Keyword arguments:
    source -- list of source files
    savedir -- where to save the YAML output
    """
    f_yml = os.path.join(savedir, 'scratch_fortran.yml')
    cloc_wrapper(sources, f_yml)
    return process_YAML_Fortran(f_yml)


def cloc_wrapper(files, ofile):
    """Counts lines of code in files listed.

    Keyword arguments:
    files -- list of source code files
    ofile -- name of the output file
   """
    out = cloc_command('@PERL_EXECUTABLE@', '@PROJECT_SOURCE_DIR@/doc/gfx/cloc.pl', files, '--yaml')
    temp = tempfile.TemporaryFile()
    try:
        temp.write(out)
        temp.seek(0)
        lines = temp.readlines()
        outfile = open(ofile, 'wb')
        outfile.writelines(lines[6:])
        outfile.close()
    finally:
        temp.close()


def process_YAML_CXX(cloc_hpp, cloc_cpp):
    """Counts lines of code in files listed.

    Keyword arguments:
    cloc_hpp -- YAML output file from cloc.pl for header files
    cloc_cpp -- YAML output file from cloc.pl for source files
    """
    # Import YAML file and get relevant data
    hpp_files = 0
    hpp_blank = 0
    hpp_comment = 0
    hpp_code = 0
    try:
        data = load(open(cloc_hpp, 'r'), Loader=Loader)
        hpp_files = data['C/C++ Header']['nFiles']
        hpp_blank = data['C/C++ Header']['blank']
        hpp_comment = data['C/C++ Header']['comment']
        hpp_code = data['C/C++ Header']['code']
    except IOError:
        pass
    # Import YAML file and get relevant data
    cpp_files = 0
    cpp_blank = 0
    cpp_comment = 0
    cpp_code = 0
    try:
        data = load(open(cloc_cpp, 'r'), Loader=Loader)
        cpp_files = data['C++']['nFiles']
        cpp_blank = data['C++']['blank']
        cpp_comment = data['C++']['comment']
        cpp_code = data['C++']['code']
    except IOError:
        pass
    return [hpp_files, hpp_blank, hpp_comment, hpp_code, cpp_files, cpp_blank, cpp_comment, cpp_code]


def process_YAML_C(cloc_h, cloc_c):
    """Counts lines of code in files listed.

    Keyword arguments:
    cloc_h -- YAML output file from cloc.pl for header files
    cloc_c -- YAML output file from cloc.pl for source files
    """
    # Import YAML file and get relevant data
    h_files = 0
    h_blank = 0
    h_comment = 0
    h_code = 0
    try:
        data = load(open(cloc_h, 'r'), Loader=Loader)
        h_files = data['C/C++ Header']['nFiles']
        h_blank = data['C/C++ Header']['blank']
        h_comment = data['C/C++ Header']['comment']
        h_code = data['C/C++ Header']['code']
    except IOError:
        pass
    # Import YAML file and get relevant data
    c_files = 0
    c_blank = 0
    c_comment = 0
    c_code = 0
    try:
        data = load(open(cloc_c, 'r'), Loader=Loader)
        c_files = data['C']['nFiles']
        c_blank = data['C']['blank']
        c_comment = data['C']['comment']
        c_code = data['C']['code']
    except IOError:
        pass
    return [h_files, h_blank, h_comment, h_code, c_files, c_blank, c_comment, c_code]


def process_YAML_Fortran(cloc_f):
    """Counts lines of code in files listed.

    Keyword arguments:
    cloc_f -- YAML output file from cloc.pl for header files
    """
    # Import YAML file and get relevant data
    data = load(open(cloc_f, 'r'), Loader=Loader)
    f77_files = 0
    f77_blank = 0
    f77_comment = 0
    f77_code = 0
    if 'Fortran 77' in data:
        f77_files = data['Fortran 77']['nFiles']
        f77_blank = data['Fortran 77']['blank']
        f77_comment = data['Fortran 77']['comment']
        f77_code = data['Fortran 77']['code']
    f90_files = data['Fortran 90']['nFiles']
    f90_blank = data['Fortran 90']['blank']
    f90_comment = data['Fortran 90']['comment']
    f90_code = data['Fortran 90']['code']
    return [f77_files + f90_files, f77_blank + f90_blank, f77_comment + f90_comment, f77_code + f90_code]


def header():
    """Print header of matplotlib script generating bar chart.

    Keyword arguments:
    plot_script -- name of the plotting script
    """

    header = """#!/usr/bin/env python
# Automatically generated on {now}
# Data obtained from the cloc.pl Perl script.
# cloc script by Al Danial, available at http://cloc.sourceforge.net/
# licensed under the GNU General Public License v2
# (c) Roberto Di Remigio  <roberto.d.remigio@uit.no>
# licensed under the GNU Lesser General Public License
    """.format(now=time.strftime('%c'))
    return header


def data_CXX(data, tag):
    """ Print data gathered from cloc.pl for C++ sources.

    Keyword arguments:
    data -- lines of code count
    tag  --  tag for the lines of code count data
    """

    data_CXX = """
save_root = \'@PROJECT_SOURCE_DIR@/doc/gfx\'
tag = \'{tag}\'
language        = \'C++\'
nr_files_hpp    = {data[0]:d}
nr_blanks_hpp   = {data[1]:d}
nr_comments_hpp = {data[2]:d}
nr_code_hpp     = {data[3]:d}
nr_files_cpp    = {data[4]:d}
nr_blanks_cpp   = {data[5]:d}
nr_comments_cpp = {data[6]:d}
nr_code_cpp     = {data[7]:d}
nr_files    = nr_files_hpp + nr_files_cpp
nr_blanks   = nr_blanks_hpp + nr_blanks_cpp
nr_comments = nr_comments_hpp + nr_comments_cpp
nr_code     = nr_code_hpp + nr_code_cpp
annotation  = \'Library: {{0}}\\nLanguage: {{1}} \\nFiles: {{2:d}}\'.format(tag, language, nr_files)
    """.format(
        tag=tag, data=data)
    return data_CXX


def data_C(data, tag):
    """ Print data gathered from cloc.pl for C sources.

    Keyword arguments:
    data -- lines of code count
    tag  --  tag for the lines of code count data
    """

    data_C = """
save_root = \'@PROJECT_SOURCE_DIR@/doc/gfx\'
tag = \'{tag}\'
language        = \'C++\'
nr_files_h    = {data[0]:d}
nr_blanks_h   = {data[1]:d}
nr_comments_h = {data[2]:d}
nr_code_h     = {data[3]:d}
nr_files_c    = {data[4]:d}
nr_blanks_c   = {data[5]:d}
nr_comments_c = {data[6]:d}
nr_code_c     = {data[7]:d}
nr_files    = nr_files_h + nr_files_c
nr_blanks   = nr_blanks_h + nr_blanks_c
nr_comments = nr_comments_h + nr_comments_c
nr_code     = nr_code_h + nr_code_c
annotation  = \'Library: {{0}}\\nLanguage: {{1}} \\nFiles: {{2:d}}\'.format(tag, language, nr_files)
    """.format(
        tag=tag, data=data)
    return data_C


def data_Fortran(data, tag):
    """ Print data gathered from cloc.pl for Fortran sources.

    Keyword arguments:
    data -- lines of code count
    tag  --  tag for the lines of code count data
    """

    data_Fortran = """
save_root = \'@PROJECT_SOURCE_DIR@/doc/gfx\'
tag = \'{tag}\'
language        = \'Fortran\'
nr_files    = {data[0]:d}
nr_blanks   = {data[1]:d}
nr_comments = {data[2]:d}
nr_code     = {data[3]:d}
annotation  = \'Library: {{0}}\\nLanguage: {{1}} \\nFiles: {{2:d}}\'.format(tag, language, nr_files)
    """.format(
        tag=tag, data=data)
    return data_Fortran
